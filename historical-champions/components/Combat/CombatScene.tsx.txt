// Copy everything below this line
import React, { useState, useEffect, useRef } from 'react';
import { CharacterId, BattleStats } from '../../types';
import { CHARACTERS, ARENAS } from '../../constants';
import { soundManager } from '../../services/soundService';
import { HealthBar } from './HealthBar';
import { Shield, Zap, Sword, MoveLeft, MoveRight, ArrowUp, Keyboard } from 'lucide-react';

interface Props {
  playerCharacterId: CharacterId;
  enemyCharacterId: CharacterId;
  onBattleEnd: (victory: boolean, stats: BattleStats) => void;
}

// --- PHYSICS CONSTANTS ---
const GRAVITY = 2.8;
const FRICTION = 0.82; 
const MOVE_SPEED = 2.2; 
const JUMP_FORCE = -45;
const GROUND_OFFSET = 120; 
const LUNGE_FORCE = 15; 

// --- PARTICLE INTERFACE ---
interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    color: string;
    size: number;
}

export const CombatScene: React.FC<Props> = ({ playerCharacterId, enemyCharacterId, onBattleEnd }) => {
  const [hudState, setHudState] = useState({
    playerHp: CHARACTERS[playerCharacterId].baseStats.health,
    playerMaxHp: CHARACTERS[playerCharacterId].baseStats.health,
    playerPower: 0,
    enemyHp: CHARACTERS[enemyCharacterId].baseStats.health,
    enemyMaxHp: CHARACTERS[enemyCharacterId].baseStats.health,
    combo: 0
  });
  
  const [countDown, setCountDown] = useState<number | string>(3);
  const [showResult, setShowResult] = useState<'VICTORY' | 'DEFEAT' | null>(null);

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const requestRef = useRef<number>(0);
  const inputsRef = useRef<{ [key: string]: boolean }>({});
  
  // Stats Tracking
  const battleStartTimeRef = useRef<number>(0);
  const maxComboRef = useRef<number>(0);
  
  // Particles Ref
  const particlesRef = useRef<Particle[]>([]);
  
  // Asset Refs
  const imagesRef = useRef<{ [key: string]: HTMLImageElement }>({});
  const arenaImgRef = useRef<HTMLImageElement | null>(null);

  // Game Logic State
  const gameState = useRef({
    active: false,
    paused: true,
    shake: 0,
    hitStop: 0, 
    player: {
      x: 0, y: 0, vx: 0, vy: 0, // Initial X will be set dynamically
      hp: CHARACTERS[playerCharacterId].baseStats.health,
      maxHp: CHARACTERS[playerCharacterId].baseStats.health,
      power: 0, 
      state: 'IDLE' as 'IDLE' | 'WALK' | 'JUMP' | 'ATTACK' | 'BLOCK' | 'HIT' | 'SPECIAL',
      dir: 1, 
      timer: 0, 
      scale: CHARACTERS[playerCharacterId].scale || 1.0,
      id: playerCharacterId,
      isEnemy: false,
      aiCooldown: 0
    },
    enemy: {
      x: 0, y: 0, vx: 0, vy: 0, // Initial X will be set dynamically
      hp: CHARACTERS[enemyCharacterId].baseStats.health,
      maxHp: CHARACTERS[enemyCharacterId].baseStats.health,
      power: 0,
      state: 'IDLE' as 'IDLE' | 'WALK' | 'JUMP' | 'ATTACK' | 'BLOCK' | 'HIT' | 'SPECIAL',
      dir: -1,
      timer: 0,
      scale: CHARACTERS[enemyCharacterId].scale || 1.0,
      id: enemyCharacterId,
      isEnemy: true,
      aiCooldown: 0
    }
  });

  // --- INITIALIZATION ---
  useEffect(() => {
    soundManager.unlockAudio();

    const pData = CHARACTERS[playerCharacterId];
    const eData = CHARACTERS[enemyCharacterId];
    const arena = ARENAS[Math.floor(Math.random() * ARENAS.length)];

    const loadImg = (src: string) => {
        const img = new Image();
        img.src = src;
        return img;
    };

    imagesRef.current['p_idle'] = loadImg(pData.imageSrc);
    imagesRef.current['p_atk'] = loadImg(pData.attackImageSrc);
    imagesRef.current['e_idle'] = loadImg(eData.imageSrc);
    imagesRef.current['e_atk'] = loadImg(eData.attackImageSrc);
    
    const bg = new Image();
    bg.src = arena.image;
    arenaImgRef.current = bg;

    // Handle Resize logic, now also responsible for setting initial positions
    const handleResize = () => {
        const canvas = canvasRef.current;
        if (!canvas || !canvas.parentElement) {
            return; 
        }
        
        const parentRect = canvas.parentElement.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        canvas.width = parentRect.width * dpr;
        canvas.height = parentRect.height * dpr;
        
        const width = canvas.width / dpr;
        const groundY = canvas.height / dpr - GROUND_OFFSET;
        
        // Always set Y position to ground when resizing to prevent characters floating
        gameState.current.player.y = groundY;
        gameState.current.enemy.y = groundY;
        
        // Always set X positions based on percentage for responsiveness
        gameState.current.player.x = width * 0.2; // 20% from left
        gameState.current.enemy.x = width * 0.8; // 20% from right
        
        // Ensure characters are within bounds after resize
        if (gameState.current.player.x < 50) gameState.current.player.x = 50;
        if (gameState.current.player.x > width - 50) gameState.current.player.x = width - 50;
        if (gameState.current.enemy.x < 50) gameState.current.enemy.x = 50;
        if (gameState.current.enemy.x > width - 50) gameState.current.enemy.x = width - 50;
    };
    
    handleResize(); // Call once immediately to set initial dimensions and positions
    window.addEventListener('resize', handleResize);

    // Start game loop only if canvas is valid AFTER dimensions have been set
    if (canvasRef.current) { 
        gameState.current.active = true;
        requestRef.current = requestAnimationFrame(gameLoop);
    } else {
        console.warn("CombatScene: CanvasRef.current was null when trying to start game loop.");
    }

    let timer = 3;
    const interval = setInterval(() => {
        timer--;
        if (timer > 0) {
            setCountDown(timer);
            soundManager.playSelect();
        } else if (timer === 0) {
            setCountDown("FIGHT!");
            soundManager.playSpecial();
        } else {
            setCountDown(-1); 
            clearInterval(interval);
            gameState.current.paused = false;
            battleStartTimeRef.current = Date.now();
        }
    }, 1000);

    return () => {
        cancelAnimationFrame(requestRef.current);
        clearInterval(interval);
        window.removeEventListener('resize', handleResize);
        gameState.current.active = false;
    };
  }, []); // Empty dependency array means this effect runs once on mount

  // --- INPUT HANDLERS ---
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
        if (e.repeat) {}
        switch(e.code) {
            case 'KeyA': case 'ArrowLeft': handleInput('left', true); break;
            case 'KeyD': case 'ArrowRight': handleInput('right', true); break;
            case 'KeyW': case 'ArrowUp': handleInput('jump', true); break;
            case 'KeyJ': triggerAttack(); break;
            case 'KeyK': triggerSpecial(); break;
            case 'KeyL': handleInput('block', true); break; 
        }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
        switch(e.code) {
            case 'KeyA': case 'ArrowLeft': handleInput('left', false); break;
            case 'KeyD': case 'ArrowRight': handleInput('right', false); break;
            case 'KeyW': case 'ArrowUp': handleInput('jump', false); break;
            case 'KeyL': handleInput('block', false); break; 
        }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  const handleInput = (action: string, active: boolean) => {
    inputsRef.current[action] = active;
  };

  const triggerAttack = () => {
      if (gameState.current.paused) return;
      const p = gameState.current.player;
      if (p.state !== 'ATTACK' && p.state !== 'HIT' && p.state !== 'BLOCK' && p.state !== 'SPECIAL') {
          p.state = 'ATTACK';
          p.timer = 12; 
          const dist = Math.abs(p.x - gameState.current.enemy.x);
          const lungePower = dist < 140 ? 2 : LUNGE_FORCE; 
          p.vx = p.dir * lungePower; 
          soundManager.playAttack(); 
      }
  };

  const triggerSpecial = () => {
    if (gameState.current.paused) return;
    const p = gameState.current.player;
    if (p.power >= 100 && p.state !== 'ATTACK' && p.state !== 'HIT' && p.state !== 'BLOCK') {
        p.state = 'SPECIAL';
        p.timer = 40; 
        p.power = 0; 
        p.vx = p.dir * 45; 
        gameState.current.shake = 20;
        soundManager.playSpecial();
        setHudState(prev => ({ ...prev, playerPower: 0 }));
    }
  };

  const createHitParticles = (x: number, y: number, isBlock: boolean) => {
      const count = isBlock ? 8 : 15;
      for(let i=0; i<count; i++) {
          let color = isBlock ? '#60a5fa' : '#ef4444'; 
          if (isBlock && Math.random() > 0.4) {
              color = '#fef08a'; 
          }
          particlesRef.current.push({
              x: x + (Math.random() - 0.5) * 40,
              y: y - 100 + (Math.random() - 0.5) * 40,
              vx: (Math.random() - 0.5) * (isBlock ? 35 : 20), 
              vy: (Math.random() - 0.5) * (isBlock ? 35 : 20),
              life: 1.0,
              color: color,
              size: Math.random() * (isBlock ? 3 : 6) + 2
          });
      }
  };

  // --- GAME ENGINE ---
  const gameLoop = () => {
      if (!gameState.current.active || !canvasRef.current) return;

      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      const dpr = window.devicePixelRatio || 1;
      const width = canvas.width / dpr;
      const height = canvas.height / dpr;
      const groundY = height - GROUND_OFFSET;

      const state = gameState.current;
      const { player: p1, enemy: p2 } = state;

      // HITSTOP LOGIC (Standard, No Slow-Mo)
      if (state.hitStop > 0) {
          state.hitStop--; 
          renderScene(ctx, width, height, groundY, dpr);
          requestRef.current = requestAnimationFrame(gameLoop);
          return;
      }

      // --- LOGIC UPDATE ---
      if (!state.paused) {
          // PLAYER LOGIC
          if (p1.state !== 'HIT' && p1.state !== 'ATTACK' && p1.state !== 'SPECIAL') {
              if (inputsRef.current['block']) { 
                  p1.state = 'BLOCK';
                  p1.vx *= 0.8;
              } else {
                  if (p1.state === 'BLOCK') p1.state = 'IDLE';
                  if (inputsRef.current['left']) { p1.vx -= MOVE_SPEED; p1.dir = -1; p1.state = 'WALK'; }
                  else if (inputsRef.current['right']) { p1.vx += MOVE_SPEED; p1.dir = 1; p1.state = 'WALK'; }
                  else { if (p1.state === 'WALK') p1.state = 'IDLE'; }
                  if (inputsRef.current['jump'] && p1.y >= groundY) { p1.vy = JUMP_FORCE; p1.state = 'JUMP'; }
              }
          }

          // ENEMY AI
          const dist = Math.abs(p1.x - p2.x);
          const isBerserk = p2.hp < p2.maxHp * 0.3;
          
          if (p2.state !== 'HIT' && p2.state !== 'ATTACK' && p2.state !== 'SPECIAL' && p2.state !== 'BLOCK') {
               if (p2.aiCooldown > 0) p2.aiCooldown--;

               if (p2.aiCooldown <= 0) {
                   if (p2.power >= 100 && (dist < 500 || isBerserk)) {
                       p2.state = 'SPECIAL';
                       p2.timer = 40;
                       p2.power = 0;
                       p2.vx = p2.dir * 45;
                       state.shake = 20;
                       soundManager.playSpecial();
                   }
                   else if (dist < 320) { 
                       const reactionRoll = Math.random();
                       if (p1.state === 'ATTACK') {
                           if (isBerserk && reactionRoll < 0.4) {
                                p2.state = 'ATTACK';
                                p2.timer = 12;
                                p2.vx = p2.dir * (dist < 140 ? 2 : LUNGE_FORCE);
                                soundManager.playAttack();
                           } else if (reactionRoll < 0.95) {
                               p2.state = 'BLOCK';
                               p2.timer = 20;
                               p2.aiCooldown = 1; 
                           }
                       } 
                       else {
                           p2.state = 'ATTACK';
                           p2.timer = 12;
                           p2.vx = p2.dir * (dist < 140 ? 2 : LUNGE_FORCE);
                           soundManager.playAttack(); 
                           p2.aiCooldown = isBerserk ? 2 : 5 + Math.random() * 8; 
                       }
                   } 
                   else {
                       const chaseSpeed = MOVE_SPEED * (isBerserk ? 1.8 : 1.5);
                       if (p1.x > p2.x) { p2.vx += chaseSpeed; p2.dir = 1; }
                       else { p2.vx -= chaseSpeed; p2.dir = -1; }
                       p2.state = 'WALK';
                       p2.aiCooldown = 2; 
                   }
               }
               
               if (p2.state !== 'ATTACK' && p2.state !== 'SPECIAL') {
                   p2.dir = p1.x > p2.x ? 1 : -1;
               }
          }
          else if (p2.state === 'BLOCK') {
              p2.timer--;
              if (p2.timer <= 0) p2.state = 'IDLE';
              p2.vx *= 0.5;
          }

          // PHYSICS & BOUNDS
          [p1, p2].forEach(char => {
              char.vy += GRAVITY;
              char.vx *= FRICTION;
              char.x += char.vx;
              char.y += char.vy;
              if (char.y > groundY) { char.y = groundY; char.vy = 0; if (char.state === 'JUMP') char.state = 'IDLE'; }
              if (char.x < 50) { char.x = 50; char.vx = 0; }
              if (char.x > width - 50) { char.x = width - 50; char.vx = 0; }
          });

          // COLLISION
          const distDX = p1.x - p2.x;
          const combinedBodyWidth = 140; 
          if (Math.abs(p1.y - p2.y) < 100 && Math.abs(distDX) < combinedBodyWidth) {
              const center = (p1.x + p2.x) / 2;
              const push = combinedBodyWidth / 2;
              if (p1.x < p2.x) { p1.x = center - push; p2.x = center + push; if (p1.vx > 0) p1.vx = 0; if (p2.vx < 0) p2.vx = 0; } 
              else { p1.x = center + push; p2.x = center - push; if (p1.vx < 0) p1.vx = 0; if (p2.vx > 0) p2.vx = 0; }
          }

          // HIT DETECTION
          [p1, p2].forEach((attacker, i) => {
              const defender = i === 0 ? p2 : p1;
              
              if (attacker.state === 'ATTACK' || attacker.state === 'SPECIAL') {
                  attacker.timer--;
                  if (attacker.timer === 0) attacker.state = 'IDLE';

                  const impactFrame = attacker.state === 'SPECIAL' ? 20 : 8;

                  if (attacker.timer === impactFrame) {
                      const range = Math.abs(attacker.x - defender.x);
                      if (range < 330 && Math.abs(attacker.y - defender.y) < 150) {
                          const facingTarget = (attacker.dir === 1 && defender.x > attacker.x) || (attacker.dir === -1 && defender.x < attacker.x);
                          
                          if (facingTarget) {
                              if (defender.state === 'BLOCK' && attacker.state !== 'SPECIAL') { 
                                  defender.vx = attacker.dir * 12; 
                                  soundManager.playBlock();
                                  createHitParticles((attacker.x + defender.x)/2, defender.y - 50, true);
                                  state.hitStop = 4;
                                  if (i === 0) {
                                      setHudState(prev => ({ ...prev, combo: 0 }));
                                  }
                              } else {
                                  // HIT LOGIC
                                  let damageMult = attacker.state === 'SPECIAL' ? 2.5 : 1.0;
                                  if (attacker.isEnemy) damageMult *= 1.2; 
                                  const dmg = CHARACTERS[attacker.id].baseStats.attack * damageMult;
                                  
                                  defender.hp = Math.max(0, defender.hp - dmg);
                                  defender.state = 'HIT';
                                  defender.timer = 20;
                                  
                                  const isSpecial = attacker.state === 'SPECIAL';
                                  defender.vx = attacker.dir * (isSpecial ? 45 : 25); 
                                  state.shake = isSpecial ? 35 : 15; 
                                  
                                  // KILL BLOW LOGIC - Snappy, no Slow Motion
                                  if (defender.hp <= 0) {
                                      state.hitStop = 15; // Brief pause for impact
                                      state.shake = 30; // Strong shake
                                  } else {
                                      state.hitStop = isSpecial ? 10 : 5;
                                  }
                                  
                                  createHitParticles(defender.x, defender.y - 80, false);
                                  soundManager.playHit();
                                  attacker.power = Math.min(100, attacker.power + (isSpecial ? 0 : 20));
                                  defender.power = Math.min(100, defender.power + 10);

                                  if (i === 0) {
                                      const newCombo = hudState.combo + 1;
                                      if (newCombo > maxComboRef.current) maxComboRef.current = newCombo;
                                      
                                      setHudState(prev => ({ 
                                          ...prev, enemyHp: defender.hp, combo: newCombo, playerPower: p1.power
                                      }));
                                  } else {
                                      setHudState(prev => ({ ...prev, playerHp: defender.hp, combo: 0, playerPower: p1.power }));
                                  }
                              }
                          }
                      }
                  }
              } else if (attacker.state === 'HIT') {
                  attacker.timer--;
                  if (attacker.timer <= 0) {
                      attacker.state = 'IDLE';
                      if (attacker.isEnemy) attacker.aiCooldown = Math.random() < 0.5 ? 0 : 5;
                  }
              }
          });
          
          if (p1.hp <= 0 || p2.hp <= 0) {
              // Wait for hitstop to finish before pausing
              if (state.hitStop <= 0) {
                  state.paused = true;
                  const victory = p2.hp <= 0;
                  setShowResult(victory ? 'VICTORY' : 'DEFEAT');
                  soundManager.playVictory();
                  
                  const duration = (Date.now() - battleStartTimeRef.current) / 1000;
                  const battleStats: BattleStats = {
                      winnerId: victory ? p1.id : p2.id,
                      loserId: victory ? p2.id : p1.id,
                      remainingHpPercentage: Math.floor((victory ? p1.hp : p2.hp) / (victory ? p1.maxHp : p2.maxHp) * 100),
                      maxCombo: maxComboRef.current,
                      durationSeconds: Math.floor(duration)
                  };

                  setTimeout(() => onBattleEnd(victory, battleStats), 3000);
              }
          }
      }

      renderScene(ctx, width, height, groundY, dpr);
      requestRef.current = requestAnimationFrame(gameLoop);
  };

  const renderScene = (ctx: CanvasRenderingContext2D, width: number, height: number, groundY: number, dpr: number) => {
      const state = gameState.current;
      const { player: p1, enemy: p2 } = state;

      ctx.setTransform(1, 0, 0, 1, 0, 0); 
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.scale(dpr, dpr);

      // Camera Shake
      if (state.shake > 0) {
          const dx = (Math.random() - 0.5) * state.shake;
          const dy = (Math.random() - 0.5) * state.shake;
          ctx.translate(dx, dy);
          state.shake *= 0.9;
          if (state.shake < 0.5) state.shake = 0;
      }

      // Background
      if (arenaImgRef.current) {
          const parallaxX = (p1.x / width) * -50;
          ctx.drawImage(arenaImgRef.current, parallaxX - 20, 0, width + 100, height);
      } else {
          ctx.fillStyle = '#222';
          ctx.fillRect(0, 0, width, height);
      }
      
      // Shadows
      [p1, p2].forEach(char => {
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.beginPath();
          ctx.ellipse(char.x, groundY, 60, 15, 0, 0, Math.PI * 2);
          ctx.fill();
      });

      // Character Draw
      const drawCharacter = (char: typeof p1, imgKeyPrefix: string) => {
          ctx.save();
          ctx.translate(char.x, char.y);
          ctx.scale(char.dir * char.scale, char.scale);

          let img = imagesRef.current[`${imgKeyPrefix}_idle`];
          if (char.state === 'ATTACK' || char.state === 'SPECIAL') img = imagesRef.current[`${imgKeyPrefix}_atk`] || img;
          
          if (char.state === 'HIT') ctx.filter = 'brightness(2) sepia(1) hue-rotate(-50deg)';
          if (char.state === 'BLOCK') ctx.filter = 'brightness(0.5)';
          
          if (char.state === 'SPECIAL') {
             const pulse = Math.abs(Math.sin(Date.now() / 150));
             ctx.filter = `brightness(1.5) drop-shadow(0 0 ${10 + pulse * 15}px gold)`;
          }

          if (char.isEnemy) {
              ctx.shadowColor = '#ef4444'; 
              ctx.shadowBlur = 20;
          }

          if (img) {
              const h = 400; 
              const w = (img.width / img.height) * h;
              const lungeOffset = (char.state === 'ATTACK' || char.state === 'SPECIAL') ? 60 : 0; 
              ctx.drawImage(img, (-w/2) + lungeOffset, -h, w, h);
          } else {
              ctx.fillStyle = 'red';
              ctx.fillRect(-50, -200, 100, 200);
          }
          
          if (char.state === 'BLOCK') {
             ctx.strokeStyle = '#3b82f6';
             ctx.lineWidth = 5;
             ctx.shadowBlur = 0;
             ctx.beginPath();
             ctx.arc(0, -150, 80, 0, Math.PI*2);
             ctx.stroke();
          }

          ctx.restore();
      };

      drawCharacter(p1, 'p');
      drawCharacter(p2, 'e');

      // DRAW PARTICLES
      particlesRef.current.forEach((p, index) => {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.05;
      });
      particlesRef.current = particlesRef.current.filter(p => p.life > 0);
      ctx.globalAlpha = 1.0;
  };

  const bindTouch = (action: string) => ({
      onPointerDown: (e: React.PointerEvent) => { e.preventDefault(); e.stopPropagation(); handleInput(action, true); },
      onPointerUp: (e: React.PointerEvent) => { e.preventDefault(); e.stopPropagation(); handleInput(action, false); },
      onPointerLeave: (e: React.PointerEvent) => { e.preventDefault(); e.stopPropagation(); handleInput(action, false); }
  });

  return (
    <div className="relative w-full h-full bg-black overflow-hidden select-none touch-none">
        <canvas ref={canvasRef} className="block w-full h-full" />

        {/* HUD */}
        <div className="absolute top-0 left-0 right-0 p-4 z-10 flex justify-between items-start pointer-events-none">
             <HealthBar current={hudState.playerHp} max={hudState.playerMaxHp} name={CHARACTERS[playerCharacterId].name} avatar={CHARACTERS[playerCharacterId].portraitSrc} />
             <div className="flex flex-col items-center pt-2">
                <div className="w-16 h-8 bg-slate-900/80 rounded border border-yellow-600 flex items-center justify-center font-mono text-yellow-500 font-bold">
                    99
                </div>
             </div>
             <HealthBar current={hudState.enemyHp} max={hudState.enemyMaxHp} isEnemy name={CHARACTERS[enemyCharacterId].name} avatar={CHARACTERS[enemyCharacterId].portraitSrc} />
        </div>
        
        {/* COUNTDOWN */}
        {countDown !== -1 && (
            <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
                <div key={countDown} className="animate-bounce">
                    {typeof countDown === 'number' ? (
                        <span className="text-[12rem] font-black text-white italic drop-shadow-[0_0_50px_rgba(255,255,255,0.8)] stroke-black text-stroke">
                            {countDown}
                        </span>
                    ) : (
                        <span className="text-[8rem] md:text-[10rem] font-black text-red-600 italic uppercase tracking-tighter drop-shadow-[0_0_80px_rgba(220,38,38,1)] animate-pulse scale-150 block">
                            FIGHT!
                        </span>
                    )}
                </div>
            </div>
        )}

        {/* COMBO */}
        {hudState.combo > 1 && (
            <div className="absolute top-32 left-8 z-10 animate-bounce pointer-events-none">
                <span className="text-6xl font-black text-yellow-400 italic stroke-black text-stroke">{hudState.combo}</span>
                <span className="block text-xl font-bold text-white uppercase -mt-2">Hits</span>
            </div>
        )}

        {/* RESULT */}
        {showResult && (
            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/70 backdrop-blur-sm animate-in zoom-in duration-300">
                <h1 className={`text-8xl font-black italic uppercase tracking-tighter ${showResult === 'VICTORY' ? 'text-yellow-400' : 'text-red-600'}`}>
                    {showResult}
                </h1>
            </div>
        )}

        {/* --- MOBILE CONTROLS OVERLAY --- */}
        <div className="absolute inset-0 z-40 pointer-events-none flex flex-col justify-end pb-8 px-6">
            <div className="flex justify-between items-end w-full">
                <div className="pointer-events-auto flex flex-col items-center gap-2">
                     <button {...bindTouch('jump')} className="w-16 h-16 rounded-full bg-slate-700/80 border-2 border-slate-500 flex items-center justify-center active:bg-slate-500 active:scale-95 shadow-lg backdrop-blur-sm mb-2">
                        <ArrowUp size={28} className="text-white" />
                     </button>
                     <div className="flex gap-4">
                        <button {...bindTouch('left')} className="w-20 h-20 rounded-full bg-slate-800/80 border-2 border-slate-500 flex items-center justify-center active:bg-slate-600 active:scale-95 shadow-xl backdrop-blur-sm">
                            <MoveLeft size={32} className="text-white" />
                        </button>
                        <button {...bindTouch('right')} className="w-20 h-20 rounded-full bg-slate-800/80 border-2 border-slate-500 flex items-center justify-center active:bg-slate-600 active:scale-95 shadow-xl backdrop-blur-sm">
                            <MoveRight size={32} className="text-white" />
                        </button>
                     </div>
                </div>

                <div className="pointer-events-auto flex items-end gap-4 relative">
                    <button {...bindTouch('block')} className="w-16 h-16 rounded-full bg-blue-900/80 border-2 border-blue-400 flex items-center justify-center active:bg-blue-800 active:scale-90 shadow-lg backdrop-blur-sm mb-2">
                        <Shield size={24} className="text-white" />
                    </button>
                    <button 
                        onPointerDown={(e) => { e.preventDefault(); triggerAttack(); }} 
                        className="w-24 h-24 rounded-full bg-gradient-to-br from-red-600 to-red-800 border-4 border-red-400 flex items-center justify-center active:scale-90 shadow-2xl active:shadow-inner"
                    >
                        <Sword size={40} className="text-white drop-shadow-md" />
                    </button>
                    <button 
                        onPointerDown={(e) => { e.preventDefault(); triggerSpecial(); }}
                        disabled={hudState.playerPower < 100}
                        className={`absolute -top-24 right-0 w-20 h-20 rounded-full border-4 flex items-center justify-center shadow-[0_0_15px_rgba(234,179,8,0.5)] transition-all
                            ${hudState.playerPower >= 100 
                                ? 'bg-yellow-500 border-yellow-200 animate-pulse scale-110' 
                                : 'bg-slate-800/80 border-slate-600 opacity-50 grayscale'}
                        `}
                    >
                        <Zap size={32} className="text-white fill-white" />
                    </button>
                </div>
            </div>
        </div>
        
        <div className="absolute bottom-4 right-4 hidden lg:flex flex-col items-end gap-1 pointer-events-none opacity-60">
            <div className="text-xs font-black text-white uppercase tracking-widest mb-1 flex items-center gap-2"><Keyboard size={14}/> PC Controls</div>
            <div className="bg-black/80 p-2 rounded border border-white/20 text-[10px] text-white font-mono leading-tight text-right">
                <p><span className="text-yellow-400">W A D</span> - MOVE / JUMP</p>
                <p><span className="text-yellow-400">J</span> - ATTACK</p>
                <p><span className="text-yellow-400">K</span> - SPECIAL</p>
                <p><span className="text-yellow-400">L</span> - BLOCK</p>
            </div>
        </div>

        <div className="absolute bottom-4 left-1/2 -translate-x-1/2 w-1/3 h-3 bg-slate-900 rounded-full border border-slate-700 overflow-hidden z-10">
            <div className="h-full bg-yellow-400 transition-all duration-300 shadow-[0_0_10px_gold]" style={{ width: `${hudState.playerPower}%` }}></div>
        </div>
    </div>
  );
};
// Copy everything above this line